{
  "hash": "bb686558ad08a20eaf9708cc98d11afc",
  "result": {
    "markdown": "# Data Wrangling {#sec-wrangle}\n\n## Intended Learning Outcomes {#sec-ilo-wrangle .unnumbered}\n\n* Be able to select and filter data for relevance\n* Be able to create new columns and edit existing ones\n* Be able to handle missing data\n\n## Walkthrough video {#sec-walkthrough-wrangle .unnumbered}\n\nThere is a walkthrough video of this chapter available via [Echo360.](https://echo360.org.uk/media/dc1e2869-a6c2-45d8-ab40-cb85cdb67f43/public) Please note that there may have been minor edits to the book since the video was recorded. Where there are differences, the book should always take precedence.\n\n## Set-up {#sec-setup-wrangle}\n\nFirst, create a new project for the work we'll do in this chapter named <code class='path'>09-wrangle</code>. Second, open and save and new R Markdown document named `wrangle.Rmd`, delete the welcome text and load the required packages for this chapter.\n\n\n::: {.cell layout-align=\"center\" filename='Chapter packages'}\n\n```{.r .cell-code}\nlibrary(tidyverse)   # data wrangling functions\n```\n:::\n\n\nYou'll need to make a folder called \"data\" and download a data file into it: \n<a href=\"https://psyteachr.github.io/ads-v1/data/budget.csv\" download>budget.csv</a>.\n\nDownload the [Data transformation cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf).\n\n## Wrangling functions\n\nData wrangling refers to the process of cleaning, transforming, and restructuring your data to get it into the format you need for analysis and it's something you will spend an awful lot of time doing. Most <a class='glossary' target='_blank' title='The process of preparing data for visualisation and statistical analysis.' href='https://psyteachr.github.io/glossary/d#data-wrangling'>data wrangling</a> involves the reshaping functions you learned in @sec-tidy and six functions from the <pkg>dplyr</pkg> package that is loaded as part of the <pkg>tidyverse</pkg>: `select`, `filter`, `arrange`, `mutate`, `summarise`, and `group_by`. You'll remember the last two from @sec-summary, so we'll only cover them briefly.\n\nIt's worth highlighting that in this chapter we're going to cover these common functions and common uses of said functions. However, <pkg>dplyr</pkg> (and packages beyond it) has a huge number of additional wrangling functions and each function has many different arguments. Essentially, if you think you should be able to wrangle your data in a particular way that we haven't explicitly shown you, you almost certainly can, it might just take a bit of Googling to find out how. \n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\nWe'll use a small example table with the sales, expenses, and satisfaction for two years from four regions over two products. After you load the data, use `glimpse(budget)` or `View(budget)` to get familiar with the data.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget <- read_csv(\"data/budget.csv\", show_col_types = FALSE)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"region\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"product\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"sales_2019\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"sales_2020\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"expenses_2019\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"expenses_2020\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"satisfaction_2019\"],\"name\":[7],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"satisfaction_2020\"],\"name\":[8],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"North\",\"2\":\"widgets\",\"3\":\"2129\",\"4\":\"-517\",\"5\":\"822\",\"6\":\"-897\",\"7\":\"high\",\"8\":\"very high\"},{\"1\":\"North\",\"2\":\"gadgets\",\"3\":\"723\",\"4\":\"77\",\"5\":\"1037\",\"6\":\"1115\",\"7\":\"very high\",\"8\":\"very high\"},{\"1\":\"South\",\"2\":\"widgets\",\"3\":\"1123\",\"4\":\"-1450\",\"5\":\"1004\",\"6\":\"672\",\"7\":\"high\",\"8\":\"neutral\"},{\"1\":\"South\",\"2\":\"gadgets\",\"3\":\"2022\",\"4\":\"-945\",\"5\":\"-610\",\"6\":\"200\",\"7\":\"low\",\"8\":\"low\"},{\"1\":\"East\",\"2\":\"widgets\",\"3\":\"-728\",\"4\":\"-51\",\"5\":\"-801\",\"6\":\"-342\",\"7\":\"very low\",\"8\":\"very low\"},{\"1\":\"East\",\"2\":\"gadgets\",\"3\":\"-423\",\"4\":\"-354\",\"5\":\"94\",\"6\":\"2036\",\"7\":\"neutral\",\"8\":\"high\"},{\"1\":\"West\",\"2\":\"widgets\",\"3\":\"633\",\"4\":\"790\",\"5\":\"783\",\"6\":\"-315\",\"7\":\"neutral\",\"8\":\"neutral\"},{\"1\":\"West\",\"2\":\"gadgets\",\"3\":\"1204\",\"4\":\"426\",\"5\":\"433\",\"6\":\"-136\",\"7\":\"low\",\"8\":\"low\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n### Select\n\nYou can select a subset of the columns (variables) in a table to make it easier to view or to prepare a table for display. You can also select columns in a new order.\n\n#### By name or index\n\nYou can select columns by name or number (which is sometimes referred to as the column index). Selecting by number can be useful when the column names are long or complicated.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# select single column by name\nproduct_dat <- budget %>% select(product) \n\n# select single column by number\nproduct_dat <- budget %>% select(2) \n```\n:::\n\n\nYou can select each column individually, separated by commas (e.g., `region, sales_2019`) but you can also select all columns from one to another by separating them with a colon (e.g., `sales_2019:expenses_2020`).\n\nThe colon notation can be much faster because you don't need to type out each individual variable name, but make sure that you know what order your columns are in and always check the output to make sure you have selected what you intended.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# select columns individually\nsales2019 <- budget %>% select(region, product, sales_2019)\n\n# select columns with colon\nsales2019 <- budget %>% select(region:sales_2019)\n```\n:::\n\n\nYou can rename columns at the same time as selecting them by setting `new_name = old_col`. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nregions <- budget %>% select(`Sales Region` = 1, 3:6)\n\nhead(regions, 2)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"Sales Region\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"sales_2019\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"sales_2020\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"expenses_2019\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"expenses_2020\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"North\",\"2\":\"2129\",\"3\":\"-517\",\"4\":\"822\",\"5\":\"-897\"},{\"1\":\"North\",\"2\":\"723\",\"3\":\"77\",\"4\":\"1037\",\"5\":\"1115\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n#### Un-selecting columns\n\nYou can select columns either by telling R which ones you want to keep as in the previous examples, or by specifying which ones you want to exclude by using a minus symbol to un-select columns. You can also use the colon notation to de-select columns, but to do so you need to put parentheses around the span first, e.g., `-(sales_2019:expenses_2020)`, not `-sales_2019:expenses_2020`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# de-select individual columns\nsales <- budget %>% select(-expenses_2019, -expenses_2020)\n\n# de-select a range of columns\nsales <- budget %>% select(-(expenses_2019:expenses_2020))\n```\n:::\n\n\n#### Select helpers\n\nFinally, you can select columns based on criteria about the column names.\n\n| function | definition |\n|----------|------------|\n| `starts_with()` | select columns that start with a character string|\n| `ends_with()` | select columns that end with a character string |\n| `contains()` | select columns that contain a character string |\n| `num_range()` | select columns with a name that matches the pattern `prefix` |\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n::: {.callout-note .try}\nWhat are the resulting columns for these four examples?\n\n* `budget %>% select(contains(\"_\"))`\n    <div class='webex-radiogroup' id='radio_XTFJQPGEZQ'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_XTFJQPGEZQ\" value=\"x\"></input> <span>sales_2019, sales_2020</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_XTFJQPGEZQ\" value=\"x\"></input> <span>sales_2020, expenses_2020, satisfaction_2020</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_XTFJQPGEZQ\" value=\"answer\"></input> <span>sales_2019, sales_2020, expenses_2019, expenses_2020, satisfaction_2019, satisfaction_2020</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_XTFJQPGEZQ\" value=\"x\"></input> <span>expenses_2019, expenses_2020</span></label></div>\n\n* `budget %>% select(num_range(\"expenses_\", 2019:2020))`\n    <div class='webex-radiogroup' id='radio_QRPKTEFUAG'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_QRPKTEFUAG\" value=\"x\"></input> <span>sales_2019, sales_2020</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_QRPKTEFUAG\" value=\"x\"></input> <span>sales_2020, expenses_2020, satisfaction_2020</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_QRPKTEFUAG\" value=\"x\"></input> <span>sales_2019, sales_2020, expenses_2019, expenses_2020, satisfaction_2019, satisfaction_2020</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_QRPKTEFUAG\" value=\"answer\"></input> <span>expenses_2019, expenses_2020</span></label></div>\n\n* `budget %>% select(starts_with(\"sales\"))`\n    <div class='webex-radiogroup' id='radio_ESRGPINQAC'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_ESRGPINQAC\" value=\"answer\"></input> <span>sales_2019, sales_2020</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_ESRGPINQAC\" value=\"x\"></input> <span>sales_2020, expenses_2020, satisfaction_2020</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_ESRGPINQAC\" value=\"x\"></input> <span>sales_2019, sales_2020, expenses_2019, expenses_2020, satisfaction_2019, satisfaction_2020</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_ESRGPINQAC\" value=\"x\"></input> <span>expenses_2019, expenses_2020</span></label></div>\n \n* `budget %>% select(ends_with(\"2020\"))`\n    <div class='webex-radiogroup' id='radio_KYKIYSISEM'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_KYKIYSISEM\" value=\"x\"></input> <span>sales_2019, sales_2020</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_KYKIYSISEM\" value=\"answer\"></input> <span>sales_2020, expenses_2020, satisfaction_2020</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_KYKIYSISEM\" value=\"x\"></input> <span>sales_2019, sales_2020, expenses_2019, expenses_2020, satisfaction_2019, satisfaction_2020</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_KYKIYSISEM\" value=\"x\"></input> <span>expenses_2019, expenses_2020</span></label></div>\n\n:::\n\n\n### Filter\n\nWhilst `select()` chooses the columns you want to retain, `filter()` chooses the rows to retain by matching row or column criteria.\n\nYou can filter by a single criterion. This criterion can be rows where a certain column's value matches a character value (e.g., \"North\") or a number (e.g., 9003). It can also be the result of a logical equation (e.g., keep all rows with a specific column value larger than a certain value). The criterion is checked for each row, and if the result is FALSE, the row is removed. You can reverse equations by specifying `!=` where `!` means \"not\".\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# select all rows where region equals North\nbudget %>% filter(region == \"North\")\n\n# select all rows where expenses_2020 were exactly equal to 200\nbudget %>% filter(expenses_2020 == 200)\n\n# select all rows where sales_2019 was more than 100\nbudget %>% filter(sales_2019 > 100)\n\n# everything but the North\nbudget %>% filter(region != \"North\")\n```\n:::\n\n\n::: {.callout-warning}\nRemember to use `==` and not `=` to check if two things are equivalent. A single `=` assigns the right-hand value to the left-hand variable (much like the `<-` operator).\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n::: {.callout-note .try}\nWhich IDs are kept from the table below?\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"id\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"grade\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"score\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"1\",\"2\":\"A\",\"3\":\"95\"},{\"1\":\"2\",\"2\":\"A\",\"3\":\"91\"},{\"1\":\"3\",\"2\":\"C\",\"3\":\"76\"},{\"1\":\"4\",\"2\":\"B\",\"3\":\"84\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n* `demo %>% filter(score < 80)`\n    <select class='webex-select'><option value='blank'></option><option value='x'>1, 2</option><option value='x'>2</option><option value='answer'>3</option><option value='x'>3, 4</option></select>\n* `demo %>% filter(grade == \"A\")`\n    <select class='webex-select'><option value='blank'></option><option value='answer'>1, 2</option><option value='x'>2</option><option value='x'>3</option><option value='x'>3, 4</option></select>\n* `demo %>% filter(grade != \"A\")`\n    <select class='webex-select'><option value='blank'></option><option value='x'>1, 2</option><option value='x'>2</option><option value='x'>3</option><option value='answer'>3, 4</option></select>\n* `demo %>% filter(score == 91)`\n    <select class='webex-select'><option value='blank'></option><option value='x'>1, 2</option><option value='answer'>2</option><option value='x'>3</option><option value='x'>3, 4</option></select>\n    \n\n:::\n\nYou can also select on multiple criteria by separating them by commas (rows will be kept if they match *all* criteria). Additionally, you can use `&` (\"and\") and `|` (\"or\") to create complex criteria.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# regions and products with profit in both 2019 and 2020\nprofit_both <- budget %>% \n  filter(\n    sales_2019 > expenses_2019,\n    sales_2020 > expenses_2020\n  )\n\n# the same as above, using & instead of a comma\nprofit_both <- budget %>% \n  filter(\n    sales_2019 > expenses_2019 &\n    sales_2020 > expenses_2020\n  )\n\n# regions and products with profit in 2019 or 2020\nprofit_either <- budget %>% \n  filter(\n    sales_2019 > expenses_2019 |\n    sales_2020 > expenses_2020\n  )\n\n# 2020 profit greater than 1000\nprofit_1000 <- budget %>%\n  filter(sales_2020 - expenses_2020 > 1000)\n```\n:::\n\n\nIf you want the filter to retain multiple specific values in the same variable, the <a class='glossary' target='_blank' title='A binary operator (%in%) that returns a logical vector indicating if there is a match or not for its left operand.' href='https://psyteachr.github.io/glossary/m#match-operator'>match operator</a> (`%in%`) should be used rather than `|` (or). The `!` can also be used in combination here, but it is placed before the variable name.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# retain any rows where region is north or south, and where product equals widget\nbudget %>%\n  filter(region %in% c(\"North\", \"South\"),\n         product == \"widgets\")\n\n# retain any rows where the region is not east or west, and where the product does not equal gadgets\nbudget %>%\n  filter(!region %in% c(\"East\", \"West\"),\n         product != \"gadgets\")\n```\n:::\n\n\n<a class='glossary' target='_blank' title='A symbol that performs some mathematical or comparative process. ' href='https://psyteachr.github.io/glossary/o#operator'>Operator</a>\t|Name   |is TRUE if and only if\n-----------|----------------------|---------------------------------\n`A < B`    |less than \t          |A is less than B\n`A <= B`   |less than or equal    |A is less than or equal to B\n`A > B`    |greater than \t        |A is greater than B\n`A >= B`   |greater than or equal |A is greater than or equal to B\n`A == B`   |equivalence \t        |A exactly equals B\n`A != B`   |not equal \t          |A does not exactly equal B\n`A %in% B` |in \t                  |A is an element of vector B\n\nFinally, you can also pass many other functions to filter. For example, the package <pkg>stringr</pkg> that is loaded as part of the <pkg>tidyverse</pkg> contains many different functions for working with <a class='glossary' target='_blank' title='A piece of text inside of quotes.' href='https://psyteachr.github.io/glossary/s#string'>strings</a> (character data). For example, you you use `str_detect()` to only retain rows where the customer satisfaction rating includes the word \"high\"\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget %>%\n  filter(str_detect(satisfaction_2019, \"high\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"region\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"product\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"sales_2019\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"sales_2020\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"expenses_2019\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"expenses_2020\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"satisfaction_2019\"],\"name\":[7],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"satisfaction_2020\"],\"name\":[8],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"North\",\"2\":\"widgets\",\"3\":\"2129\",\"4\":\"-517\",\"5\":\"822\",\"6\":\"-897\",\"7\":\"high\",\"8\":\"very high\"},{\"1\":\"North\",\"2\":\"gadgets\",\"3\":\"723\",\"4\":\"77\",\"5\":\"1037\",\"6\":\"1115\",\"7\":\"very high\",\"8\":\"very high\"},{\"1\":\"South\",\"2\":\"widgets\",\"3\":\"1123\",\"4\":\"-1450\",\"5\":\"1004\",\"6\":\"672\",\"7\":\"high\",\"8\":\"neutral\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nNote that `str_detect()` is case sensitive so it would not return values of \"High\" or \"HIGH\". You can use the function `tolower()` or `toupper()` to convert a string to lowercase or uppercase before you search for substring if you need case-insensitive matching.\n\n::: {.callout-warning}\n`filter()` is incredibly powerful and can allow you to select very specific subsets of data. But, it is also quite dangerous because when you start combining multiple criteria and operators, it's very easy to accidentally specify something slightly different than what you intended. **Always check your output**. If you have a small dataset, then you can eyeball it to see if it looks right. With a larger dataset, you may wish to compute summary statistics or count the number of groups/observations in each variable to verify your filter is correct. There is no level of expertise in coding that can substitute knowing and checking your data. \n:::\n\n### Arrange\n\nYou can sort your dataset using `arrange()`. You will find yourself needing to sort data in R much less than you do in Excel, since you don't need to have rows next to each other in order to, for example, calculate group means. But `arrange()` can be useful when preparing data for display in tables. `arrange()` works on character data where it will sort alphabetically, as well as numeric data where the default is ascending order (smallest to largest). Reverse the order using `desc()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# arranging the table \n# first by product in alphabetical order\n# then by \"region\" in reverse alphabetical order\nbudget %>%\n  arrange(product, desc(region))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"region\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"product\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"sales_2019\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"sales_2020\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"expenses_2019\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"expenses_2020\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"satisfaction_2019\"],\"name\":[7],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"satisfaction_2020\"],\"name\":[8],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"West\",\"2\":\"gadgets\",\"3\":\"1204\",\"4\":\"426\",\"5\":\"433\",\"6\":\"-136\",\"7\":\"low\",\"8\":\"low\"},{\"1\":\"South\",\"2\":\"gadgets\",\"3\":\"2022\",\"4\":\"-945\",\"5\":\"-610\",\"6\":\"200\",\"7\":\"low\",\"8\":\"low\"},{\"1\":\"North\",\"2\":\"gadgets\",\"3\":\"723\",\"4\":\"77\",\"5\":\"1037\",\"6\":\"1115\",\"7\":\"very high\",\"8\":\"very high\"},{\"1\":\"East\",\"2\":\"gadgets\",\"3\":\"-423\",\"4\":\"-354\",\"5\":\"94\",\"6\":\"2036\",\"7\":\"neutral\",\"8\":\"high\"},{\"1\":\"West\",\"2\":\"widgets\",\"3\":\"633\",\"4\":\"790\",\"5\":\"783\",\"6\":\"-315\",\"7\":\"neutral\",\"8\":\"neutral\"},{\"1\":\"South\",\"2\":\"widgets\",\"3\":\"1123\",\"4\":\"-1450\",\"5\":\"1004\",\"6\":\"672\",\"7\":\"high\",\"8\":\"neutral\"},{\"1\":\"North\",\"2\":\"widgets\",\"3\":\"2129\",\"4\":\"-517\",\"5\":\"822\",\"6\":\"-897\",\"7\":\"high\",\"8\":\"very high\"},{\"1\":\"East\",\"2\":\"widgets\",\"3\":\"-728\",\"4\":\"-51\",\"5\":\"-801\",\"6\":\"-342\",\"7\":\"very low\",\"8\":\"very low\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n::: {.callout-note .try}\nIf you want to sort character data/categories in a specific order, turn the column into a <a class='glossary' target='_blank' title='A data type where a specific set of values are stored with labels; An explanatory variable manipulated by the experimenter' href='https://psyteachr.github.io/glossary/f#factor'>factor</a> and set the `levels` in the desired order.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget %>%\n  mutate(region = factor(region, levels = c(\"North\", \"South\", \"East\", \"West\"))) %>%\n  filter(product == \"gadgets\") %>%\n  arrange(region)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"region\"],\"name\":[1],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"product\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"sales_2019\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"sales_2020\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"expenses_2019\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"expenses_2020\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"satisfaction_2019\"],\"name\":[7],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"satisfaction_2020\"],\"name\":[8],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"North\",\"2\":\"gadgets\",\"3\":\"723\",\"4\":\"77\",\"5\":\"1037\",\"6\":\"1115\",\"7\":\"very high\",\"8\":\"very high\"},{\"1\":\"South\",\"2\":\"gadgets\",\"3\":\"2022\",\"4\":\"-945\",\"5\":\"-610\",\"6\":\"200\",\"7\":\"low\",\"8\":\"low\"},{\"1\":\"East\",\"2\":\"gadgets\",\"3\":\"-423\",\"4\":\"-354\",\"5\":\"94\",\"6\":\"2036\",\"7\":\"neutral\",\"8\":\"high\"},{\"1\":\"West\",\"2\":\"gadgets\",\"3\":\"1204\",\"4\":\"426\",\"5\":\"433\",\"6\":\"-136\",\"7\":\"low\",\"8\":\"low\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n:::\n\n### Mutate\n\nThe function `mutate()` allows you to add new columns or change existing ones by overwriting them by using the syntax `new_column = operation`.  You can add more than one column in the same mutate function by separating the columns with a comma. Once you make a new column, you can use it in further column definitions. For example, the creation of `profit` below uses the column `expenses`, which is created above it.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget2 <- budget %>%\n  mutate(\n    sales = sales_2019 + sales_2020,\n    expenses = expenses_2019 + expenses_2020,\n    profit = sales - expenses,\n    region = paste(region, \"Office\")\n  )\n```\n:::\n\n\n`mutate()` can also be used in conjunction with other functions and Boolean operators. For example, we can add another column to `budget2` that states whether a profit was returned that year or overwrite our `product` variable as a factor. Just like when we used <a class='glossary' target='_blank' title='An expression that evaluates to TRUE or FALSE.' href='https://psyteachr.github.io/glossary/b#boolean-expression'>Boolean expressions</a> with filter, it will evaluate the equation and return TRUE or FALSE depending on whether the observation meets the criteria.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget2 <- budget2 %>%\n  mutate(profit_category = profit > 0,\n         product = as.factor(product))\n```\n:::\n\n\n::: {.callout-warning}\nYou can overwrite a column by giving a new column the same name as the old column (see `region` or `product`) above. Make sure that you mean to do this and that you aren't trying to use the old column value after you redefine it.\n:::\n\nYou can also use `case_when()` to specify what values to return, rather than defaulting to TRUE or FALSE:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget3 <- budget2 %>%\n  mutate(profit_category = case_when(profit > 0 ~ \"PROFIT\",\n                                     profit < 0 ~ \"NO PROFIT\"))\n```\n:::\n\n\nUse it to recode values:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# create a column where people get a bonus if customer satisfaction was overall high or very high\n\nbonus <- budget3 %>%\n  mutate(bonus_2019 = case_when(satisfaction_2019 %in% c(\"very low\", \"low\", \"neutral\") ~ \"no bonus\",\n                                satisfaction_2019 %in% c(\"high\", \"very high\") ~ \"bonus\"))\n```\n:::\n\n\nAnd combine different criteria:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# new management takes over - people only get a bonus if customer satisfaction was overall high or very high AND if a profit was returned\n\nbonus2 <- budget3 %>%\n  mutate(bonus_2020 = case_when(satisfaction_2020 == \"high\" & \n                                  profit_category == \"PROFIT\" ~ \"bonus\",\n                                satisfaction_2020 == \"very high\" & \n                                  profit_category == \"PROFIT\" ~ \"bonus\",\n                                TRUE ~ \"No bonus\")) # set all other values to \"no bonus\"\n```\n:::\n\n\nJust like `filter()`, `mutate()` is incredibly powerful and the scope of what you can create is far beyond what we can cover in this book. \n\n### Summarise {#sec-dplyr-summarise}\n\nYou were introduced to the `summarise()` function in @sec-summary-summarise. This applies summary functions to an entire table (or groups, as you'll see in the next section).\n\nLet's say we want to determine the mean sales and expenses, plus the minimum and maximum profit, for any region, product and year. First, we need to reshape the data like we learned in @sec-tidy, so that there is a column for year and one column each for sales and expenses, instead of separate columns for each year. We'll also drop the satisfaction data as we don't need it for this analysis. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget4 <- budget %>%\n  select(-satisfaction_2019, -satisfaction_2020) %>%\n  pivot_longer(cols = sales_2019:expenses_2020,\n               names_to = c(\"type\", \"year\"),\n               names_sep = \"_\",\n               values_to = \"value\") %>%\n  pivot_wider(names_from = type,\n              values_from = value)\n\nhead(budget4) # check the format\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"region\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"product\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"year\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"sales\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"expenses\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"North\",\"2\":\"widgets\",\"3\":\"2019\",\"4\":\"2129\",\"5\":\"822\"},{\"1\":\"North\",\"2\":\"widgets\",\"3\":\"2020\",\"4\":\"-517\",\"5\":\"-897\"},{\"1\":\"North\",\"2\":\"gadgets\",\"3\":\"2019\",\"4\":\"723\",\"5\":\"1037\"},{\"1\":\"North\",\"2\":\"gadgets\",\"3\":\"2020\",\"4\":\"77\",\"5\":\"1115\"},{\"1\":\"South\",\"2\":\"widgets\",\"3\":\"2019\",\"4\":\"1123\",\"5\":\"1004\"},{\"1\":\"South\",\"2\":\"widgets\",\"3\":\"2020\",\"4\":\"-1450\",\"5\":\"672\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nNow we can create summary statistics for the table.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbudget4 %>%\n  summarise(\n    mean_sales = mean(sales),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales)\n  )\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"mean_sales\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"mean_expenses\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"min_profit\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"max_profit\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"291.1875\",\"2\":\"318.4375\",\"3\":\"-2632\",\"4\":\"2390\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n### Group By {#sec-dplyr-groupby}\n\nYou were introduced to the `group_by()` function in @sec-grouping. For example, you can break down the summary statistics above by year and product.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nyear_prod <- budget4 %>%\n  group_by(year, product) %>%\n  summarise(\n    mean_sales = mean(sales),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales)\n  ) %>%\n  ungroup()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'year'. You can override using the\n`.groups` argument.\n```\n:::\n\n```{.r .cell-code}\nyear_prod\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"year\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"product\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"mean_sales\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"mean_expenses\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"min_profit\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"max_profit\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"2019\",\"2\":\"gadgets\",\"3\":\"881.50\",\"4\":\"238.50\",\"5\":\"-2632\",\"6\":\"517\"},{\"1\":\"2019\",\"2\":\"widgets\",\"3\":\"789.25\",\"4\":\"452.00\",\"5\":\"-1307\",\"6\":\"150\"},{\"1\":\"2020\",\"2\":\"gadgets\",\"3\":\"-199.00\",\"4\":\"803.75\",\"5\":\"-562\",\"6\":\"2390\"},{\"1\":\"2020\",\"2\":\"widgets\",\"3\":\"-307.00\",\"4\":\"-220.50\",\"5\":\"-1105\",\"6\":\"2122\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\nNote that you can use the other wrangling functions on the summary table, for example: \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# arrange by maximum profit\nyear_prod %>%\n  arrange(desc(max_profit))\n\n# filter out gadgets\nyear_prod %>%\n  filter(product != \"gadgets\")\n```\n:::\n\n\n\n::: {.callout-note .try}\nHow would you find out the maximum sales for each region?\n\n\n::: {.cell layout-align=\"center\"}\n<div class='webex-radiogroup' id='radio_JBEVUELPZX'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_JBEVUELPZX\" value=\"x\"></input> <span><pre>budget3 %>%\n  group_by(region) %>%\n  summarise(max_sales = max(region)</pre></span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_JBEVUELPZX\" value=\"x\"></input> <span><pre>budget3 %>%\n  group_by(sales) %>%\n  summarise(max_sales = max(sales)</pre></span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_JBEVUELPZX\" value=\"answer\"></input> <span><pre>budget3 %>%\n  group_by(region) %>%\n  summarise(max_sales = max(sales)</pre></span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_JBEVUELPZX\" value=\"x\"></input> <span><pre>budget3 %>%\n  group_by(sales) %>%\n  summarise(max_sales = max(region)</pre></span></label></div>\n:::\n\n\n:::\n\nYou can also use `group_by()` in combination with other functions. For example, `slice_max()` returns the top N rows, ordered by a specific variable.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# return top 3 sales\nbudget4 %>%\n  slice_max(n = 3, order_by = sales)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"region\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"product\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"year\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"sales\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"expenses\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"North\",\"2\":\"widgets\",\"3\":\"2019\",\"4\":\"2129\",\"5\":\"822\"},{\"1\":\"South\",\"2\":\"gadgets\",\"3\":\"2019\",\"4\":\"2022\",\"5\":\"-610\"},{\"1\":\"West\",\"2\":\"gadgets\",\"3\":\"2019\",\"4\":\"1204\",\"5\":\"433\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nBut this can be combined with `group_by()` to return the top sales for each region:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# return top sale for each region\nbudget4 %>%\n  group_by(region) %>%\n  slice_max(n = 1, order_by = sales)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"region\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"product\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"year\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"sales\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"expenses\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"East\",\"2\":\"widgets\",\"3\":\"2020\",\"4\":\"-51\",\"5\":\"-342\"},{\"1\":\"North\",\"2\":\"widgets\",\"3\":\"2019\",\"4\":\"2129\",\"5\":\"822\"},{\"1\":\"South\",\"2\":\"gadgets\",\"3\":\"2019\",\"4\":\"2022\",\"5\":\"-610\"},{\"1\":\"West\",\"2\":\"gadgets\",\"3\":\"2019\",\"4\":\"1204\",\"5\":\"433\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## Complications\n\n### Rounding\n\nLet's say we want to round all the values to the nearest pound. The pattern below uses the `across()` function to apply the `round()` function to the columns from `mean_sales` to `max_profit`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nyear_prod %>%\n  mutate(across(.cols = mean_sales:max_profit, \n                .fns = round))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"year\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"product\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"mean_sales\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"mean_expenses\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"min_profit\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"max_profit\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"2019\",\"2\":\"gadgets\",\"3\":\"882\",\"4\":\"238\",\"5\":\"-2632\",\"6\":\"517\"},{\"1\":\"2019\",\"2\":\"widgets\",\"3\":\"789\",\"4\":\"452\",\"5\":\"-1307\",\"6\":\"150\"},{\"1\":\"2020\",\"2\":\"gadgets\",\"3\":\"-199\",\"4\":\"804\",\"5\":\"-562\",\"6\":\"2390\"},{\"1\":\"2020\",\"2\":\"widgets\",\"3\":\"-307\",\"4\":\"-220\",\"5\":\"-1105\",\"6\":\"2122\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nIf you compare this table to the one in @sec-dplyr-groupby, you'll see that the 2019 gadgets mean sales rounded up from 881.5 to 882, while the mean expenses rounded down from 238.5 to 238. What's going on!?\n\nThis may seem like a mistake, but R rounds .5 to the nearest even number, rather than always up, like you were probably taught in school. This prevents overestimation biases, since x.5 is *exactly* halfway between x and x+1, so there is no reason it should always round up.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nround(0.5)\nround(1.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n[1] 2\n```\n:::\n:::\n\n\nHowever, this might throw a monkey wrench into your own systems. For example, our school policy is to round up for course marks at x.5. The solution is to define your own version of `round()` (modified from [Andrew Landgraf's blog](http://andrewlandgraf.com/2012/06/15/rounding-in-r/){target=\"_blank\"}). Put it in a hidden code block at the top of your script, with a clear warning that this is changing the way `round()` normally works. You don't need to understand how this function works, just how to use it.\n\nwhen you run this code, a new section will appear in the environment pane labelled \"Functions\". In addition to using functions from packages, you can also make your own. It's not something we are going to go into detail on in this course, but it's useful to know the functionality exists.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n#!!!!!! redefining round so 5s round up !!!!!! \nround <- function(x, digits = 0) {\n  posneg = sign(x)\n  z = abs(x)*10^digits\n  z = z + 0.5 + sqrt(.Machine$double.eps)\n  z = trunc(z)\n  z = z/10^digits\n  z*posneg\n}\n```\n:::\n\n\nNow `round()` should work as you'd expect.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nround(0.5)\nround(1.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n```\n:::\n:::\n\n\nJust remove your version if you want R to go back to the original method. Remember that you have to define the new round method in any script that uses it, and run the definition code before you use it interactively. You can check your Environment pane to see whether `round` is listed under \"Functions\".\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# remove new round() method\nrm(round)\n```\n:::\n\n\n### Missing values {#sec-missing-values}\n\nIf you have control over your data, it is always best to keep missing values as empty cells rather than denoting missingness with a word or implausible number. If you used \"missing\" rather than leaving the cell empty, the entire variable would be read as character data, which means you wouldn't be able to perform mathematical operations like calculating the mean. If you use an implausible number (0 or 999 are common), then you risk these values being included in any calculations as real numbers.\n\nHowever, we often don't have control over how the data come to us, so let's run through how to fix this.\n\n#### Bad missing values\n\nWhat if the South region hadn't returned their expenses (entered as 0) and the North region hadn't returned their sales data for 2020 yet, so someone entered it as \"missing\"?  We're going to show you two functions that you can use to recode or change values, `ifelse()` and `case_when()`. `ifelse()` is from Base R and can be slightly more intuitive to use initially. `case_when()` is from the <pkg>dplyr</pkg> and allows you to specify multiple criteria, although is slightly more difficult to use so it's good to be aware of both.\n\nFirst, we're going to recode the data to add in the missing values\n\nFor the South data, we can use `ifelse()` to set the value of expenses to 0 if the year is 2020 and region is \"South\", otherwise use the value from the expenses column (i.e., don't change).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmissing_bad <- budget4 %>%\n  mutate(expenses = ifelse(\n    test = year == 2020 & region == \"South\", \n    yes = 0, # value if above conditions are met\n    no = expenses # value if above conditions are not met\n  ))\n```\n:::\n\n\nAlternatively, we can use `case_when()` to convert the expenses for 2020 to `0`. The last line of `TRUE ~ expenses` means that the default value is retrieved from the expenses column, if none of the previous criteria applied.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmissing_bad <- budget4 %>%\n  mutate(expenses = case_when(\n    # set to 0 when year is 2020 and region is North\n    year == 2020 & region == \"South\" ~ 0, \n    # otherwise, set to the value in the expenses column\n    TRUE ~ expenses   \n  ))\n```\n:::\n\n\n\n<div class='webex-solution'><button>Using case_when() for multiple criteria</button>\n\n\nThe `case_when()` function allows allows you to set multiple criteria, although we're only using one non-default criterion here. It can be very useful, but takes a little practice.\n\nThe example below creates a label for each row. Notice how the label for the first row is \"x < 2\", even though this row also fits the second criterion \"y < 4\". This is because `case_when()` applies the first match to each row, even if other criteria in the function also match that row.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata <- tibble(\n  x = 1:5,\n  y = 1:5\n)\n\ndata %>%\n  mutate(label = case_when(\n    x < 2           ~ \"x < 2\",\n    y < 4           ~ \"y < 4\",\n    x == 5 & y == 5 ~ \"both 5\",\n    TRUE            ~ \"default\"\n  ))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"x\"],\"name\":[1],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"y\"],\"name\":[2],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"label\"],\"name\":[3],\"type\":[\"chr\"],\"align\":[\"left\"]}],\"data\":[{\"1\":\"1\",\"2\":\"1\",\"3\":\"x < 2\"},{\"1\":\"2\",\"2\":\"2\",\"3\":\"y < 4\"},{\"1\":\"3\",\"2\":\"3\",\"3\":\"y < 4\"},{\"1\":\"4\",\"2\":\"4\",\"3\":\"default\"},{\"1\":\"5\",\"2\":\"5\",\"3\":\"both 5\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n\n</div>\n\n\n\nFor the North, we need to to recode these values as \"missing\". Since this is character data, and sales are numeric data, the result will be <a class='glossary' target='_blank' title='Changing the data type of values in a vector to a single compatible type.' href='https://psyteachr.github.io/glossary/c#coercion'>coerced</a> to a character.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# set sales values to \"missing\" for North 2020 rows\nmissing_bad <- missing_bad %>%\n  mutate(sales = ifelse(year == 2020 & region == \"North\", \n                        \"missing\", \n                        sales))\n\n# check structure of data, sales now character\nstr(missing_bad)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntibble [16 × 5] (S3: tbl_df/tbl/data.frame)\n $ region  : chr [1:16] \"North\" \"North\" \"North\" \"North\" ...\n $ product : chr [1:16] \"widgets\" \"widgets\" \"gadgets\" \"gadgets\" ...\n $ year    : chr [1:16] \"2019\" \"2020\" \"2019\" \"2020\" ...\n $ sales   : chr [1:16] \"2129\" \"missing\" \"723\" \"missing\" ...\n $ expenses: num [1:16] 822 -897 1037 1115 1004 ...\n```\n:::\n:::\n\n\nIf we're using `case_when()`, first we need to convert the sales column to a character, as this function is a little pickier and won't let you combine <a class='glossary' target='_blank' title='The kind of data represented by an object.' href='https://psyteachr.github.io/glossary/d#data-type'>data types</a>, since this almost always means that you're making a mistake.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# set sales values to \"missing\" for North 2020 rows\nmissing_bad <- missing_bad %>%\n  mutate(sales = as.character(sales),\n         sales = case_when(year == 2020 & region == \"North\" ~ \"missing\", \n                           TRUE ~ sales))\n```\n:::\n\n\nNow, if you try to compute the mean sales, you will get an error message and the result will be `NA`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# try to compute mean sales\nmissing_bad %>%\n  summarise(mean_sales = mean(sales))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in mean.default(sales): argument is not numeric or logical: returning NA\n```\n:::\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"mean_sales\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"NA\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n#### Convert missing values to NA\n\nTo set the missing values to NA, you could use either `ifelse()` or `case_when()`. Because the `sales` column was converted to character, we also need to transform this back to numeric.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmissing_data <- missing_bad %>%\n  mutate(\n    # set \"0\" values to NA using ifelse\n    expenses = ifelse(expenses == 0, NA, expenses),\n    # set \"missing\" values to NA using case_when\n    sales = case_when(sales == \"missing\" ~ NA_character_,\n                      TRUE ~ sales),\n    # convert to numeric\n    sales = as.numeric(sales)\n  )\n```\n:::\n\n\n::: {.callout-warning}\nBecause `case_when()` is so picky about character types, you need to specify which type of NA you're using (there is a specific NA for each data type). If you change `NA_character_` to `NA` in the code above, you'll get the following error message:\n\n```\nError: Problem with `mutate()` column `sales`. ℹ `sales = case_when(sales == \"missing\" ~ NA, TRUE ~ sales)`. x must be a logical vector, not a character vector.\n```\n\nTechnically, `NA` has a <a class='glossary' target='_blank' title='A data type representing TRUE or FALSE values.' href='https://psyteachr.github.io/glossary/l#logical'>logical</a> data type, so functions that aren't as picky about combining data types will <a class='glossary' target='_blank' title='Changing the data type of values in a vector to a single compatible type.' href='https://psyteachr.github.io/glossary/c#coercion'>coerce</a> this to the NA version for the most compatible data type.\n:::\n\nNow, if we try to calculate the mean sales and profits, we get missing values for any summary value that used one of the North 2020 sales values or the South 2020 expenses.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmissing_data %>%\n  group_by(region) %>%\n  summarise(\n    mean_sales = mean(sales),\n    mean_expenses = mean(expenses),\n    min_profit = min(expenses - sales),\n    max_profit = max(expenses - sales),\n    .groups = \"drop\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"region\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"mean_sales\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"mean_expenses\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"min_profit\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"max_profit\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"East\",\"2\":\"-389.00\",\"3\":\"246.75\",\"4\":\"-291\",\"5\":\"2390\"},{\"1\":\"North\",\"2\":\"NA\",\"3\":\"519.25\",\"4\":\"NA\",\"5\":\"NA\"},{\"1\":\"South\",\"2\":\"187.50\",\"3\":\"NA\",\"4\":\"NA\",\"5\":\"NA\"},{\"1\":\"West\",\"2\":\"763.25\",\"3\":\"191.25\",\"4\":\"-1105\",\"5\":\"150\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n#### Ignore missing values\n\nThis is because `NA` basically means \"I don't know\", and the sum of 100 and \"I don't know\" is \"I don't know\", not 100. However, when you're calculating means, you often want to just ignore missing values. Set `na.rm = TRUE` in the summary function to remove missing values before calculating.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmissing_data %>%\n  group_by(region) %>%\n  summarise(\n    mean_sales = mean(sales, na.rm = TRUE),\n    mean_expenses = mean(expenses, na.rm = TRUE),\n    min_profit = min(expenses - sales, na.rm = TRUE),\n    max_profit = max(expenses - sales, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"region\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"mean_sales\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"mean_expenses\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"min_profit\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"max_profit\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"East\",\"2\":\"-389.00\",\"3\":\"246.75\",\"4\":\"-291\",\"5\":\"2390\"},{\"1\":\"North\",\"2\":\"1426.00\",\"3\":\"519.25\",\"4\":\"-1307\",\"5\":\"314\"},{\"1\":\"South\",\"2\":\"187.50\",\"3\":\"197.00\",\"4\":\"-2632\",\"5\":\"-119\"},{\"1\":\"West\",\"2\":\"763.25\",\"3\":\"191.25\",\"4\":\"-1105\",\"5\":\"150\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n#### Count missing values\n\nIf you want to find out how many missing or non-missing values there are in a column, use the `is.na()` function to get a <a class='glossary' target='_blank' title='A data type representing TRUE or FALSE values.' href='https://psyteachr.github.io/glossary/l#logical'>logical</a> vector of whether or not each value is missing, and use `sum()` to count how many values are TRUE or `mean()` to calculate the proportion of TRUE values.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmissing_data %>%\n  group_by(year, product) %>%\n  summarise(\n    n_valid = sum(!is.na(sales)),\n    n_missing = sum(is.na(sales)),\n    prop_missing = mean(is.na(sales)),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"year\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"product\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"n_valid\"],\"name\":[3],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"n_missing\"],\"name\":[4],\"type\":[\"int\"],\"align\":[\"right\"]},{\"label\":[\"prop_missing\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"2019\",\"2\":\"gadgets\",\"3\":\"4\",\"4\":\"0\",\"5\":\"0.00\"},{\"1\":\"2019\",\"2\":\"widgets\",\"3\":\"4\",\"4\":\"0\",\"5\":\"0.00\"},{\"1\":\"2020\",\"2\":\"gadgets\",\"3\":\"3\",\"4\":\"1\",\"5\":\"0.25\"},{\"1\":\"2020\",\"2\":\"widgets\",\"3\":\"3\",\"4\":\"1\",\"5\":\"0.25\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n#### Omit missing values\n\nYou may also want to remove rows that have missing values and only work from complete datasets. `drop_na()` will remove any row that has a missing observation. You can use `drop_na()` on the entire dataset which will remove any row that has *any* missing value, or you can specify to only remove rows that are missing a specific value.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# remove any rows with any missing values\ncomplete_data <- missing_data %>%\n  drop_na()\n\n# remove any rows that are missing a value for sales\ncomplete_sales <- missing_data %>%\n  drop_na(sales)\n```\n:::\n\n\nMissing data can be quite difficult to deal with depending on how it is represented. As always, no amount of coding expertise can make up for not understanding the structure and idiosyncrasies of your data. \n\n## Exercises {#sec-together-wrangle}\n\nLet's try some exercises using a dataset you already encountered in @sec-viz so that you can see how much more you're able to do with the data now.\n\n* Save your current Markdown, close it, and open a new Rmd named \"survey_data_mad_skillz\".\n* In the set-up code chunk, load the tidyverse, then load the dataset from https://psyteachr.github.io/ads-v1/data/survey_data.csv into an object named `survey_data`.\n* Use your method of choice to review the dataset and familiarise yourself with its structure.\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n\n<div class='webex-solution'><button>Solution</button>\n\n```{.r .cell-code}\n# from https://www.kaggle.com/kyanyoga/sample-sales-data\nlibrary(tidyverse)\nsurvey_data <- read_csv(\"https://psyteachr.github.io/ads-v1/data/survey_data.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 707 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (3): caller_id, employee_id, issue_category\ndbl  (3): wait_time, call_time, satisfaction\ndttm (1): call_start\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n\n</div>\n:::\n\n\n### Creating new categories\n\nEmployees 1-5 were trained by Michael and employees 6-10 were trained by Dwight. \n\n* Create a new column named `trainer` that lists the trainer for each employee.\n* Then, calculate the average satisfaction scores for employees trained by each trainer and visualise the satisfaction scores for each in whatever way you think best.\n\n` r hide(\"Hint\")`\nTo add the trainer column you can either use `case_when()` and specify multiple criteria (e.g., if the employee is 1-5, Michael, if the employee is 6-10 Dwight), or you could use `ifelse()` and set the `test` to Michael's employees and return `Dwight` for all others.\n` r unhide()`\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n\n<div class='webex-solution'><button>Solution</button>\n\n```{.r .cell-code}\n# case_when() method\nsurvey_data <- survey_data %>%\n  mutate(trainer = case_when(employee_id %in% c(\"E01\", \"E02\", \"E03\", \"E04\", \"E05\") ~ \"Michael\",\n                             employee_id %in% c(\"E06\", \"E07\", \"E08\", \"E09\", \"E10\") ~ \"Dwight\"))\n\n# ifelse() method\n\nsurvey_data <- survey_data %>%\n  mutate(trainer = ifelse(test = employee_id %in% c(\"E01\", \"E02\", \"E03\", \"E04\", \"E05\"),\n                           yes = \"Michael\",\n                           no = \"Dwight\"))\n\n# mean satisfaction scores\nsurvey_data %>%\n  group_by(trainer) %>%\n  summarise(mean_satisfaction = mean(satisfaction))\n\n# possible visualisation \n\nggplot(survey_data, aes(x = satisfaction, fill = trainer)) +\n  geom_histogram(binwidth = 1, show.legend = FALSE, colour = \"black\") +\n  facet_wrap(~trainer) +\n  labs(title = \"Satisfaction scores by employee trainer\")\n```\n\n::: {.cell-output-display}\n![](09-wrangle_files/figure-html/unnamed-chunk-36-1.png){fig-align='center' width=100%}\n:::\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"trainer\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"mean_satisfaction\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"Dwight\",\"2\":\"3.366755\"},{\"1\":\"Michael\",\"2\":\"3.088415\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n\n\n</div>\n:::\n\n\n### Filter by calculated score\n\nFirst, calculate the average wait time and store this in an object named `mean_wait`. This should be a single value rather than a table.\n\n\n<div class='webex-solution'><button>Hint</button>\n\nThere are multiple ways to achieve this. You could create the table and then pull out the single value, or just calculate the single value.\n\n</div>\n\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n\n<div class='webex-solution'><button>Solution</button>\n\n```{.r .cell-code}\n# method 1 - tidyverse\nmean_wait <- survey_data %>%\n  summarise(mean_wait = mean(wait_time)) %>%\n  pull(mean_wait)\n\n# method 2 - base R\nmean_wait <- mean(survey_data$wait_time)\n```\n\n\n</div>\n:::\n\n\nNow create a dataset named `long_wait` that just contains data from customers who waited more than the average wait time.\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n\n<div class='webex-solution'><button>Solution</button>\n\n```{.r .cell-code}\nlong_wait <- survey_data %>%\n  filter(wait_time > mean_wait)\n```\n\n\n</div>\n:::\n\n\nCreate a visualisation that shows how many customers waited more than the average wait time for each employee.\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n\n<div class='webex-solution'><button>Solution</button>\n\n```{.r .cell-code}\nlong_wait %>%\n  ggplot(aes(x = employee_id)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](09-wrangle_files/figure-html/unnamed-chunk-39-1.png){fig-align='center' width=100%}\n:::\n\n\n</div>\n:::\n\n\n### Multiple critera\n\nNow, add a column to `survey_data` named `follow_up` that flags whether a customer should be followed up with a courtesy phone call. Your company is short-staffed so only customers that meet all three of the following criteria should be followed-up:\n\n* Their wait time should be above the average **for all calls**\n* Their call time should be above the average **for their category**\n* Their satisfaction should be less than three 3. \n\nThis is quite complicated and there are multiple ways to achieve the desired outcome. Some approaches may need other functions that were covered in previous chapters and you may need to create intermediate objects.\n\nCall the final object `follow_data` and keep only the customer ID, employee ID, trainer, and follow up columns. \n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n\n<div class='webex-solution'><button>Solution</button>\n\n```{.r .cell-code}\n# this is one possible solution, there are many other valid approaches \n\n# calculate mean wait time across all calls\nmean_wait <- mean(survey_data$wait_time)\n\n# calculate mean call time for each category\nfollow_data <- survey_data %>%\n  group_by(issue_category) %>%\n  summarise(mean_call = mean(call_time)) %>%\n#then join it to the survey data  \n  left_join(survey_data, by = \"issue_category\") %>%\n# then add on the column\n  mutate(follow_up = case_when(wait_time > mean_wait & \n                               call_time > mean_call & \n                               satisfaction < 3 ~ \"yes\",\n                               TRUE ~ \"no\")) %>%\n  select(caller_id, employee_id, trainer, follow_up)\n```\n\n\n</div>\n:::\n\n\nFor all of the above, write code that stores the answer as a single value, so that you could easily use it in inline coding.\n\nHow many customers need to be followed up:\n\n* In total? <input class='webex-solveme nospaces' size='3' data-answer='[\"120\"]'/>\n* From calls by employee 06? <input class='webex-solveme nospaces' size='2' data-answer='[\"16\"]'/>\n* From calls by employees trained by Michael <input class='webex-solveme nospaces' size='2' data-answer='[\"65\"]'/>\n* From calls by employees trained by Dwight <input class='webex-solveme nospaces' size='2' data-answer='[\"55\"]'/>\n\n\n<div class='webex-solution'><button>Hint</button>\n\n`group_by %>% count() %>% filter() %>% pull()\n\n</div>\n\n\nWhich employee needs to make the largest number of follow-up courtesy calls? <input class='webex-solveme nospaces' size='3' data-answer='[\"E02\"]'/>\n\n\n<div class='webex-solution'><button>Hint</button>\n\nAs above but add in an `ungroup()` and `slice_max()` along the way. \n\n</div>\n\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n\n<div class='webex-solution'><button>Solution</button>\n\n```{.r .cell-code}\n# in total\nfollow_data %>%\n  group_by(follow_up) %>%\n  count()%>%\n  filter(follow_up == \"yes\") %>%\n  pull(n)\n\n# by employee 6\nfollow_data %>%\n  group_by(follow_up, employee_id) %>%\n  count() %>%\n  filter(employee_id == \"E06\",\n         follow_up == \"yes\") %>%\n  pull(n)\n\n# by michael\nfollow_data %>%\n  group_by(follow_up, trainer) %>%\n  count() %>%\n  filter(trainer == \"Michael\",\n         follow_up == \"yes\") %>%\n  pull(n)\n\n# by dwight\nfollow_data %>%\n  group_by(follow_up, trainer) %>%\n  count() %>%\n  filter(trainer == \"Dwight\",\n         follow_up == \"yes\") %>%\n  pull(n)\n\n# most follow-ups needed\nfollow_data %>%\n  group_by(follow_up, employee_id) %>%\n  count() %>%\n  ungroup() %>%\n  filter(follow_up == \"yes\") %>%\n  slice_max(n = 1, order_by = n) %>%\n  pull(employee_id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 120\n[1] 16\n[1] 65\n[1] 55\n[1] \"E02\"\n```\n:::\n\n\n</div>\n:::\n\n\n### Original insight\n\nIn preparation for the final summative assessment, explore the data to provide one original insight of your own.\n\n### Report\n\nCompile all the above into a visually appealing reproducible report that could be used to target employees and trainers for extra training (or depending on what mood you're in, to fire them). Use inline coding to report any numbers in the text. Once you're finished, post your Rmd and knitted html document on teams so that other learners can see your approach.\n\n\n## Glossary {#sec-glossary-wrangle}\n\n\n::: {.cell layout-align=\"center\"}\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> term </th>\n   <th style=\"text-align:left;\"> definition </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> [boolean expression](https://psyteachr.github.io/glossary/b.html#boolean-expression){class=\"glossary\" target=\"_blank\"} </td>\n   <td style=\"text-align:left;\"> An expression that evaluates to TRUE or FALSE. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> [coercion](https://psyteachr.github.io/glossary/c.html#coercion){class=\"glossary\" target=\"_blank\"} </td>\n   <td style=\"text-align:left;\"> Changing the data type of values in a vector to a single compatible type. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> [data type](https://psyteachr.github.io/glossary/d.html#data-type){class=\"glossary\" target=\"_blank\"} </td>\n   <td style=\"text-align:left;\"> The kind of data represented by an object. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> [data wrangling](https://psyteachr.github.io/glossary/d.html#data-wrangling){class=\"glossary\" target=\"_blank\"} </td>\n   <td style=\"text-align:left;\"> The process of preparing data for visualisation and statistical analysis. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> [factor](https://psyteachr.github.io/glossary/f.html#factor){class=\"glossary\" target=\"_blank\"} </td>\n   <td style=\"text-align:left;\"> A data type where a specific set of values are stored with labels; An explanatory variable manipulated by the experimenter </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> [logical](https://psyteachr.github.io/glossary/l.html#logical){class=\"glossary\" target=\"_blank\"} </td>\n   <td style=\"text-align:left;\"> A data type representing TRUE or FALSE values. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> [match operator](https://psyteachr.github.io/glossary/m.html#match-operator){class=\"glossary\" target=\"_blank\"} </td>\n   <td style=\"text-align:left;\"> A binary operator (%in%) that returns a logical vector indicating if there is a match or not for its left operand. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> [operator](https://psyteachr.github.io/glossary/o.html#operator){class=\"glossary\" target=\"_blank\"} </td>\n   <td style=\"text-align:left;\"> A symbol that performs some mathematical or comparative process. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> [string](https://psyteachr.github.io/glossary/s.html#string){class=\"glossary\" target=\"_blank\"} </td>\n   <td style=\"text-align:left;\"> A piece of text inside of quotes. </td>\n  </tr>\n</tbody>\n</table>\n:::\n\n\n## Further resources {#sec-resources-wrangle}\n\n* [Data transformation cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf)\n* [Chapter 5: Data Transformation ](http://r4ds.had.co.nz/transform.html) in *R for Data Science*\n* [Chapter 19: Functions](https://r4ds.had.co.nz/functions.html) in *R for Data Science*\n* [Introduction to stringr](https://stringr.tidyverse.org/articles/stringr.html)\n\n\n\n\n",
    "supporting": [
      "09-wrangle_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}